# Module 1 Lesson 5: 腳本工程：從「口述」到「寫作」

> **課程體系：Learn Python with AI IDE**
> **當前模組**：Module 1 - The AI Ready Engineer
> **本課目標**：掌握 Python 腳本檔案的物理本質，學習在終端機中建立、編輯並執行程式碼，實現從「即時對話」到「持久創作」的跨越。

---

既然已經在 M1L4 中圈好了地，並推開了 **ai_course** 專屬工作室的大門，目前的你一定摩拳擦掌，準備大幹一場。

在之前的 M1L3 中，我們體驗了 **REPL (互動式模式)**。那就像是與 Python 引擎進行一場「即時通話」，回饋雖快，但通話結束（退出 REPL），所有的內容便不復存在。在真正的軟體工程裡，我們需要將智慧結晶「記錄」下來，變成可以永久保存、隨時執行的 **腳本 (Script)**。

本課我們將挑戰最純粹的工程基本功：不依賴任何複雜的自動化軟體，僅憑最原始的工具，完成你的第一份作品。

---

## 1. 腳本的本質：它只是純文字

這是一個讓很多初學者感到意外的事實：**一個所謂的「Python 腳本」，在物理本質上就是一個純文字檔案。**

它與你在電腦上寫的 `.txt` 檔案沒有任何區別，裡面裝的都是字元。之所以叫它 `.py`，只是為了給作業系統看的一個「標籤」，告訴電腦：「嘿，這個檔案請交給 **Python 解譯器 (Interpreter)** 來閱讀並執行。」

> **🤔 什麼是「解譯器」？**
> 想像一下，你寫的是人類語言（Python 程式碼），但電腦的 CPU 只聽得懂機器語言（0 和 1）。**解譯器**就像是一個全職的**「翻譯官管家」**。當你執行腳本時，它會一行一行閱讀你的文字，翻譯成電腦能懂的指令並立刻執行。

### 🛠️ 實驗：純文字證明 (The Scribe's Trial)

我們將透過一個看似笨拙的實驗，來打破對「腳本」的神秘感。

1.  **準備選址 (Callback L2)**：
    還記得 M1L2 建立的實驗室嗎？打開終端機，確保你在「家目錄」 (`cd ~`)。如果你之前刪掉了，請重新建立一個資料夾：
    ```bash
    mkdir my_ai_project
    cd my_ai_project
    pwd
    ```
    *   **提示**：執行 `pwd` 看到的這長串路徑就是該資料夾在電腦裡的「絕對地址」。你可以複製它，或在 Finder (Mac) / 檔案總管 (Windows) 的地址列裡找到對應的位置。
2.  **建立檔案**：
    保持終端機開啟。現在請打開你的圖形化介面（Finder 或 檔案總管），進入剛才建立的 `my_ai_project` 資料夾。
3.  **系統編輯器登場**：
    *   **Apple Mac 用戶**：打開你的 **文字編輯 (TextEdit)** App。在選單列選擇「檔案」 -> 「新建」。請務必確保它處於「純文字模式」（手動檢查：若看到尺標，請按 `Shift+Command+T` 轉為純文字）。
    *   **Windows 用戶**：右鍵新建一個文字檔案，或打開電腦內建的 **記事本 (Notepad)**。
4.  **寫入第一行「寫作」程式碼**：
    在檔案裡寫下這行：
    ```python
    print("hello, written by text editor")
    ```
5.  **儲存並變魔術：更名**：
    將檔案儲存到 `my_ai_project` 資料夾中，命名為 `hello.txt`。然後在資料夾中手動將其副檔名從 `.txt` 修改為 **`.py`**。
    *   *電腦可能會彈出安全警告，請大膽點擊「確定」。*

---

## 2. 執行腳本：走進實驗室 (Callback L4)

現在，重頭戲來了。我們要讓 Python 解譯器來閱讀並執行這個剛才手工打造的腳本。

> [!IMPORTANT]
> **必須動作：啟用環境**
> 任何時候執行 Python，第一反應永遠是：我在哪個房間？
> `conda activate ai_course`
> 請確認提示字元前綴變成了 `(ai_course)`。

### 執行指令
在終端機輸入：
```bash
python hello.py
```

**預期結果**：
終端機會瞬間列印出：`hello, written by text editor`。

---

## 3. 終端機原生方式：touch 與 nano

雖然手動改副檔名能證明本質，但在工程開發中非常低效。身為一名工程師，你應該學會如何在終端機裡「一氣呵成」地完成這一切。我們將建立第二個腳本。

### 3.1 製造空瓶：`touch` (Recall M1L2)

在終端機中輸入指令，製造第二個腳本的「容器」：
```bash
touch hello_again.py
```

### 3.2 編輯內容：`nano` (你的第一個終端機編輯器)

我們要往這個空瓶子裡裝東西。輸入以下指令進入一個簡單的編輯介面：
```bash
nano hello_again.py
```
**操作指引**：
1.  在出現的黑色視窗中輸入：`print("hello, written by nano editor")`。
2.  **儲存並退出 (Survival Skill)**：
    *   按下 **`Ctrl + O`** (Write Out，儲存)。
    *   按下 **Enter 鍵** 確認檔案名稱。
    *   按下 **`Ctrl + X`** (Exit，退出)。

### 3.3 再次執行
```bash
python hello_again.py
```
**預期結果**：
列印出：`hello, written by nano editor`。

---

## 4. 殊途同歸：正式定名為「腳本」

到這一步，你會發現無論是透過記事本改名，還是透過終端機 `nano` 編寫，它們**殊途同歸**。

**現在，我們可以給這類以 `.py` 結尾的純文字檔案一個正式的工程稱呼：Python 腳本 (Python Script)。**

*   **互通性**：你用 `nano` 寫的檔案，去圖形化介面看，它也老老實實地待在 `my_ai_project` 資料夾裡。
*   **物理本質**：如果你現在把 `hello_again.py` 改名為 `hello_again.txt`，再去雙擊記事本打開，你會發現它依然是熟悉的文字。

**結論**：Python 並不神秘，它只是在執行一份「文字劇本」（腳本）而已。

---

## 5. 深度實驗：消失的結果

在 M1L3 的 REPL 中，你輸入 `1 + 1` 後按下 Enter，終端機會立刻吐出 `2`。這是因為 REPL 的 **P** (Print) 會自動幫你把結果印出來。

**但在腳本模式下，Python 變「懶」了。**

請嘗試建立一個新檔案 **`nothing.py`**，把內容寫成：
```python
1 + 1
2 ** 100
```
儲存並執行 `python nothing.py`。你會發現：**終端機一片漆黑，什麼也沒發生。**

**為什麼？**
因為在腳本裡，Python 確實默默算出了 `2` 和那串天文數字，但由於你沒有下達「列印」指令，它算完就把結果悄悄丟掉了。

---

## 6. 總結：「對話」 vs 「寫作」

透過上面的實驗，我們可以清晰地對比出兩種模式的差異：

| 特性 | REPL (互動模式 / L3) | Script (腳本模式 / L5) |
| :--- | :--- | :--- |
| **持久性** | 隨用隨棄 (口述) | 永久保存 (寫作) |
| **回饋速度** | 即時回饋 (適合實驗) | 執行前需儲存 (適合生產) |
| **自動列印** | **自動顯示結果** | **必須手動 `print()`** |
| **容錯率** | 輸錯一行只能重來 | 可以隨時修改並重複執行 |

---

## 7. 修正方法：召回遺失的結果

你必須使用 Python 裡的一個**「函式」 (Function)** —— **`print()`**，明確命令 Python ：「把結果印給我看！」

> **💡 什麼是函式 (Function)？**
> 暫時把它理解成電視遙控器上的**「功能按鍵」**。你按下一個鍵，電視就執行一個特定動作（比如靜音）。`print()` 就是那個負責「把文字傳送到螢幕上」的按鍵。關於它的詳細原理，我們在 Module 2 會有深入拆解。

```python
print(1 + 1)
print(2 ** 100)
```
重新執行，你找回了遺失的 `2` 和那個指數爆炸的結果。

---

## 8. 工程自檢 (Engineering Checkpoint)

### ✅ 驗收標準 (Pass Criteria)
1.  **位置正確**：執行 `pwd` 確認自己在 `my_ai_project` 路徑下。
2.  **檔案存在**：執行 `ls` 能看到 `hello.py`、`hello_again.py` 和 `nothing.py`。
3.  **執行正常**：三個腳本均能透過 `python` 命令正常輸出。

---

> [!IMPORTANT]
> **本課結語**
>
> 恭喜！如果你成功執行了這兩個腳本，這意味著你已經完成了從「使用工具」到「創造資產」的轉變。
>
> 雖然在 M1L3 的 REPL 中你也寫過程式碼，但只有此時此刻，當你把邏輯記錄在 `.py` 檔案中並儲存到硬碟時，你才真正創造了屬於你的第一個**數位資產 (Digital Asset)**。
>
> 過去這幾課，我們像原始人一樣在黑色荒野（終端機）裡徒手打磨石器（建立檔案、手動啟用環境、用 nano 寫作）。這種辛苦是有意義的，它讓你看清了程式碼執行最底層的真相。
>
> **忍耐已經到了極限？下一課，我們將正式迎接工程世界的「專業特化裝備」—— IDE。IDE 的全稱是整合開發環境 (Integrated Development Environment)，它就像一個全能駕駛艙，將你之前學過的終端機、路徑、環境、檔案編輯全部整合在一個介面裡，賦予你十倍的效率。那裡，也是我們在 Module 2 真正攻克 Python 語言的「終極戰場」。**
