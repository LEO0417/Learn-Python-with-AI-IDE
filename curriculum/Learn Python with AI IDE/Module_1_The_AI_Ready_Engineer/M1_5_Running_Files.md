# Module 1 Lesson 5: 脚本视角 —— 运行 Python 文件

> **Module 1: The AI-Ready Engineer**
> **目标**：从“对话”转向“创作”。理解 Python 文件的持久化执行逻辑。

---

## 1. 理论：为什么需要文件？

在上一课中我们发现，REPL 就像黑板，写完擦掉（关闭窗口）就没了。
在正式的软件工程中，我们需要将逻辑写在 **.py 文件**里，这就是所谓的 **Script (脚本)**。

**脚本的价值**：
1.  **持久化**：代码可以保存、共享、版本化。
2.  **批处理**：一次运行，执行成千上万行代码。
3.  **确定性**：确保每次运行的逻辑完全一致。

---

## 2. 机制：Shell 是如何“运行”代码的？

当你输入 `python my_script.py` 时，底层发生了什么？
这是一次跨越“主权边界”的操作：
1.  **Shell 接收指令**：你的终端（Zsh 或 PowerShell）收到了你的文字。
2.  **定位解释器**：Shell 去系统路径中找到名为 `python` 的程序（这正是我们 M1_2 中配好的环境）。
3.  **加载文件**：Python 程序像读小说一样，从磁盘上加载 `my_script.py` 的内容。
4.  **顺序执行**：Python 从文件的第一行开始，直到最后一行。结束后，Python 进程关闭，把控制权还给 Shell。

---

## 3. 指令：徒手创建并运行脚本

虽然我们最终会使用 IDE，但现在我们要用“最底层”的方式，感受代码的诞生。

### 3.1 创建文件
在终端（确保激活了 `ai_course`）中进入我们的实验目录 `lab`：
```bash
cd ~/Desktop/lab/source/code
```
创建一个新文件：
*   **Mac**: `touch runner.py`
*   **Win**: `New-Item runner.py`

### 3.2 编写内容 (使用最小编辑器)
我们暂时不打开 Antigravity，而是使用终端自带的超级简单编辑器：
```bash
nano runner.py
```
在打开的界面中输入以下代码：
```python
x = 10
y = 20
total = x + y
print("--- 自动结算系统 ---")
print("数值 X:", x)
print("数值 Y:", y)
print("总计结果:", total)
```
**保存并退出**：
*   Mac/Win: 按 `Ctrl + O` (保存)，然后回车确认，最后按 `Ctrl + X` (退出)。

### 3.3 运行脚本
在终端输入：
```bash
python runner.py
```
**观察输出**：你会看到一个整齐的结算结果。

---

## 4. 重点：环境与路径的“陷阱”

### 4.1 解释器匹配
如果你没有激活 `ai_course` 环境而运行这个命令，可能会报错说找不到 `python`，或者运行的是系统自带的老版本 Python。
**原则：始终在环境激活状态下运行。**

### 4.2 找不到文件 (FileNotFound)
如果你当前在 `~/Desktop` 目录，而文件在 `~/Desktop/lab/source/code/runner.py`。
直接打 `python runner.py` 会报错。
你必须：
*   要么 `cd` 进去。
*   要么提供**相对路径**：`python lab/source/code/runner.py`。
*   要么提供**绝对路径**。

---

## 5. 硬核练习

1.  **逻辑扩展任务**：
    再次使用 `nano runner.py`，在代码末尾增加一段逻辑：计算 `total` 的平方根（提示：使用 `total ** 0.5`）。保存并再次运行，观察输出是否同步更新。

2.  **多脚本联动猜想**：
    如果你现在创建一个 `runner2.py`，在这个文件里写下 `import runner` 会发生什么？（不要尝试，先思考。我们会在 Module 2 深度探讨这个工程话题）。

3.  **报错捕获**：
    故意在 `runner.py` 里写错一个单词（比如把 `print` 写成 `print_me`）。运行它，观察报错信息。
    **注意**：报错信息里会明确告诉你：**是在哪一行**出现了问题。这是 REPL 提供不了的结构化反馈。

---

> [!IMPORTANT]
> **本阶段总结**：
> 从 REPL 到 Script 的跨越，是你从“试用者”向“开发者”转变的关键。现在你已经可以让计算机存储并执行复杂的逻辑。
>
> **接下来，我们将告别这种“苦行僧”式的编程，迎来我们的重型装备：IDE。**
